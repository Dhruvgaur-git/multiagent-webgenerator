import json
from pathlib import Path
import zipfile
import os

def write_generated_code(frontend_code: str, backend_code: str, project_name: str) -> dict:
    try:
        base_path = Path("generated") / project_name
        base_path.mkdir(parents=True, exist_ok=True)
        frontend_data = json.loads(frontend_code)
        frontend_files = frontend_data.get("frontend", {})
        backend_data = json.loads(backend_code)
        backend_files = backend_data.get("backend", {})
        frontend_path = base_path / "frontend"
        frontend_path.mkdir(exist_ok=True)
        _write_files(frontend_path, frontend_files)
        backend_path = base_path / "backend"
        backend_path.mkdir(exist_ok=True)
        _write_files(backend_path, backend_files)
        readme_content = f"""# {project_name}

Generated by MultiAgent AI Website Generator

## Frontend
- Framework: Next.js 14/15
- UI: shadcn/ui + Aceternity UI

## Backend
- Framework: Express.js
- Database: PostgreSQL (Neon DB)

## Setup Instructions

### Frontend
cd frontend
npm install
npm run dev

### Backend
cd backend
npm install
npm start
"""
        (base_path / "README.md").write_text(readme_content)
        return {"success": True, "path": str(base_path), "files_created": True}
    except Exception as e:
        print(f"âŒ File writing error: {str(e)}")
        return {"success": False, "error": "File writing failed", "details": str(e)}

def _write_files(base_path: Path, files_dict: dict, current_path: Path = None):
    if current_path is None:
        current_path = base_path
    for name, content in files_dict.items():
        if isinstance(content, dict):
            new_path = current_path / name
            new_path.mkdir(exist_ok=True)
            _write_files(base_path, content, new_path)
        else:
            file_path = current_path / name
            file_path.parent.mkdir(parents=True, exist_ok=True)
            file_path.write_text(str(content))

def create_zip_file(project_name: str) -> Path:
    base_path = Path("generated") / project_name
    zip_path = Path("generated") / f"{project_name}.zip"
    with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        for root, dirs, files in os.walk(base_path):
            for file in files:
                file_path = Path(root) / file
                arcname = file_path.relative_to(base_path.parent)
                zipf.write(file_path, arcname)
    return zip_path
